<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>structpy.collection.hidir API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>structpy.collection.hidir</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from structpy import implementation
from structpy.collection.hidir_spec import HidirSpec

from structpy.collection.hidict import Hidict
from itertools import chain


@implementation(HidirSpec)
class Hidir(Hidict):

    def __init__(self, order, dict_like=None, superkeys=tuple()):
        Hidict.__init__(self, order, None, superkeys)
        if dict_like is not None:
            self.update(dict_like)

    def _generate_subdict(self, order, superkeys):
        return Hidir(order, None, superkeys)

    def _generate_valueset(self, keys):
        return set()

    def __contains__(self, keys):
        if not isinstance(keys, tuple):
            keys = (keys,)
        if len(keys) &lt;= self.order + 1:
            assert len(keys) &lt;= self.order + 1
            value = self
            for key in keys:
                if not dict.__contains__(value, key):
                    return False
                value = dict.__getitem__(value, key)
            return True
        elif len(keys) == self.order + 2:
            value = self
            for key in keys[:-1]:
                if not dict.__contains__(value, key):
                    return False
                value = dict.__getitem__(value, key)
            return keys[-1] in value
        else:
            raise KeyError(keys, self)

    def __setitem__(self, keys, values):
        if len(keys) &lt; self.order + 1:
            Hidict.__setitem__(self, keys, values)
        else:
            valueset = self._generate_valueset((*self.superkeys, *keys))
            set.update(valueset, values)
            Hidict.__setitem__(self, keys, valueset)

    def update(self, other):
        if isinstance(other, dict):
            stack = [(self, other, tuple())]
            while stack:
                this, other, superkeys = stack.pop()
                for key, values in dict.items(other):
                    keys = (*superkeys, key)
                    if key not in this:
                        dict.__setitem__(this, key, self._generate_subdict(self.order - len(keys), keys))
                    if len(keys) == self.order:
                        dict_updating = dict.__getitem__(this, key)
                        for k, v in values.items():
                            valueset = self._generate_valueset((*keys, k))
                            valueset.update(v)
                            dict.__setitem__(dict_updating, k, valueset)
                    else:
                        stack.append((dict.__getitem__(this, key), values, keys))
        else:
            for item in other:
                keys, value = item[:-1], item[-1]
                if not Hidict.__contains__(self, keys):
                    Hidict.__setitem__(self, keys, self._generate_valueset((*self.superkeys, *keys)))
                set.add(Hidict.__getitem__(self, keys), value)

    def values(self):
        return chain(Hidict.values(self))

    def items(self):
        stack = [(self, tuple())]
        while stack:
            this, superkeys = stack.pop()
            for key, value in dict.items(this):
                keys = (*superkeys, key)
                if len(keys) == self.order + 1:
                    yield from [(*self.superkeys, *keys, v) for v in value]
                else:
                    stack.append((dict.__getitem__(this, key), keys))


if __name__ == &#39;__main__&#39;:
    print(HidirSpec.verify(Hidir))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="structpy.collection.hidir.Hidir"><code class="flex name class">
<span>class <span class="ident">Hidir</span></span>
<span>(</span><span>order, dict_like=None, superkeys=())</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of <code><a title="structpy.collection.hidir_spec.HidirSpec" href="hidir_spec.html#structpy.collection.hidir_spec.HidirSpec">HidirSpec</a></code>
<br></p>
<pre><code>Hierarchical directory.

For an order-N hidir, N+1 ordered keys are mapped to a set of values
in each hidir entry.

Hidir supports access patterns where only part of the key sequence
is specified, allowing flexibility in lookup patterns where multiple
keys are associated with a value set.
&lt;br&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Hidir(Hidict):

    def __init__(self, order, dict_like=None, superkeys=tuple()):
        Hidict.__init__(self, order, None, superkeys)
        if dict_like is not None:
            self.update(dict_like)

    def _generate_subdict(self, order, superkeys):
        return Hidir(order, None, superkeys)

    def _generate_valueset(self, keys):
        return set()

    def __contains__(self, keys):
        if not isinstance(keys, tuple):
            keys = (keys,)
        if len(keys) &lt;= self.order + 1:
            assert len(keys) &lt;= self.order + 1
            value = self
            for key in keys:
                if not dict.__contains__(value, key):
                    return False
                value = dict.__getitem__(value, key)
            return True
        elif len(keys) == self.order + 2:
            value = self
            for key in keys[:-1]:
                if not dict.__contains__(value, key):
                    return False
                value = dict.__getitem__(value, key)
            return keys[-1] in value
        else:
            raise KeyError(keys, self)

    def __setitem__(self, keys, values):
        if len(keys) &lt; self.order + 1:
            Hidict.__setitem__(self, keys, values)
        else:
            valueset = self._generate_valueset((*self.superkeys, *keys))
            set.update(valueset, values)
            Hidict.__setitem__(self, keys, valueset)

    def update(self, other):
        if isinstance(other, dict):
            stack = [(self, other, tuple())]
            while stack:
                this, other, superkeys = stack.pop()
                for key, values in dict.items(other):
                    keys = (*superkeys, key)
                    if key not in this:
                        dict.__setitem__(this, key, self._generate_subdict(self.order - len(keys), keys))
                    if len(keys) == self.order:
                        dict_updating = dict.__getitem__(this, key)
                        for k, v in values.items():
                            valueset = self._generate_valueset((*keys, k))
                            valueset.update(v)
                            dict.__setitem__(dict_updating, k, valueset)
                    else:
                        stack.append((dict.__getitem__(this, key), values, keys))
        else:
            for item in other:
                keys, value = item[:-1], item[-1]
                if not Hidict.__contains__(self, keys):
                    Hidict.__setitem__(self, keys, self._generate_valueset((*self.superkeys, *keys)))
                set.add(Hidict.__getitem__(self, keys), value)

    def values(self):
        return chain(Hidict.values(self))

    def items(self):
        stack = [(self, tuple())]
        while stack:
            this, superkeys = stack.pop()
            for key, value in dict.items(this):
                keys = (*superkeys, key)
                if len(keys) == self.order + 1:
                    yield from [(*self.superkeys, *keys, v) for v in value]
                else:
                    stack.append((dict.__getitem__(this, key), keys))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="structpy.collection.hidict.Hidict" href="hidict.html#structpy.collection.hidict.Hidict">Hidict</a></li>
<li>builtins.dict</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="structpy.collection.enforcer.enforcer_hidir.EnforcerHidir" href="enforcer/enforcer_hidir.html#structpy.collection.enforcer.enforcer_hidir.EnforcerHidir">EnforcerHidir</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="structpy.collection.hidir.Hidir.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="structpy.collection.hidict.Hidict" href="hidict.html#structpy.collection.hidict.Hidict">Hidict</a></code>.<code><a title="structpy.collection.hidict.Hidict.update" href="hidict.html#structpy.collection.hidict.Hidict.update">update</a></code>
</p>
<div class="desc inherited"><p>D.update([E, ]**F) -&gt; None.
Update D from dict/iterable E and F.
If E is present and has a .keys() method, then does:
for k in E: D[k] = E[k]
If E …</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, other):
    if isinstance(other, dict):
        stack = [(self, other, tuple())]
        while stack:
            this, other, superkeys = stack.pop()
            for key, values in dict.items(other):
                keys = (*superkeys, key)
                if key not in this:
                    dict.__setitem__(this, key, self._generate_subdict(self.order - len(keys), keys))
                if len(keys) == self.order:
                    dict_updating = dict.__getitem__(this, key)
                    for k, v in values.items():
                        valueset = self._generate_valueset((*keys, k))
                        valueset.update(v)
                        dict.__setitem__(dict_updating, k, valueset)
                else:
                    stack.append((dict.__getitem__(this, key), values, keys))
    else:
        for item in other:
            keys, value = item[:-1], item[-1]
            if not Hidict.__contains__(self, keys):
                Hidict.__setitem__(self, keys, self._generate_valueset((*self.superkeys, *keys)))
            set.add(Hidict.__getitem__(self, keys), value)</code></pre>
</details>
</dd>
<dt id="structpy.collection.hidir.Hidir.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="structpy.collection.hidict.Hidict" href="hidict.html#structpy.collection.hidict.Hidict">Hidict</a></code>.<code><a title="structpy.collection.hidict.Hidict.values" href="hidict.html#structpy.collection.hidict.Hidict.values">values</a></code>
</p>
<div class="desc inherited"><p>D.values() -&gt; an object providing a view on D's values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values(self):
    return chain(Hidict.values(self))</code></pre>
</details>
</dd>
<dt id="structpy.collection.hidir.Hidir.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="structpy.collection.hidict.Hidict" href="hidict.html#structpy.collection.hidict.Hidict">Hidict</a></code>.<code><a title="structpy.collection.hidict.Hidict.items" href="hidict.html#structpy.collection.hidict.Hidict.items">items</a></code>
</p>
<div class="desc inherited"><p>D.items() -&gt; a set-like object providing a view on D's items</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self):
    stack = [(self, tuple())]
    while stack:
        this, superkeys = stack.pop()
        for key, value in dict.items(this):
            keys = (*superkeys, key)
            if len(keys) == self.order + 1:
                yield from [(*self.superkeys, *keys, v) for v in value]
            else:
                stack.append((dict.__getitem__(this, key), keys))</code></pre>
</details>
</dd>
<dt id="structpy.collection.hidir.Hidir.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self, *keys, default=None)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="structpy.collection.hidict.Hidict" href="hidict.html#structpy.collection.hidict.Hidict">Hidict</a></code>.<code><a title="structpy.collection.hidict.Hidict.pop" href="hidict.html#structpy.collection.hidict.Hidict.pop">pop</a></code>
</p>
<div class="desc inherited"><p>D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.
If key is not found, d is returned if given, otherwise KeyError is raised</p></div>
</dd>
<dt id="structpy.collection.hidir.Hidir.popitem"><code class="name flex">
<span>def <span class="ident">popitem</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="structpy.collection.hidict.Hidict" href="hidict.html#structpy.collection.hidict.Hidict">Hidict</a></code>.<code><a title="structpy.collection.hidict.Hidict.popitem" href="hidict.html#structpy.collection.hidict.Hidict.popitem">popitem</a></code>
</p>
<div class="desc inherited"><p>D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a
2-tuple; but raise KeyError if D is empty.</p></div>
</dd>
<dt id="structpy.collection.hidir.Hidir.setdefault"><code class="name flex">
<span>def <span class="ident">setdefault</span></span>(<span>self, *keys, default=None)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="structpy.collection.hidict.Hidict" href="hidict.html#structpy.collection.hidict.Hidict">Hidict</a></code>.<code><a title="structpy.collection.hidict.Hidict.setdefault" href="hidict.html#structpy.collection.hidict.Hidict.setdefault">setdefault</a></code>
</p>
<div class="desc inherited"><p>Insert key with a value of default if key is not in the dictionary …</p></div>
</dd>
<dt id="structpy.collection.hidir.Hidir.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, *keys, default=None)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="structpy.collection.hidict.Hidict" href="hidict.html#structpy.collection.hidict.Hidict">Hidict</a></code>.<code><a title="structpy.collection.hidict.Hidict.get" href="hidict.html#structpy.collection.hidict.Hidict.get">get</a></code>
</p>
<div class="desc inherited"><p>Return the value for key if key is in the dictionary, else default.</p></div>
</dd>
<dt id="structpy.collection.hidir.Hidir.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="structpy.collection.hidict.Hidict" href="hidict.html#structpy.collection.hidict.Hidict">Hidict</a></code>.<code><a title="structpy.collection.hidict.Hidict.keys" href="hidict.html#structpy.collection.hidict.Hidict.keys">keys</a></code>
</p>
<div class="desc inherited"><p>D.keys() -&gt; a set-like object providing a view on D's keys</p></div>
</dd>
<dt id="structpy.collection.hidir.Hidir.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="structpy.collection.hidict.Hidict" href="hidict.html#structpy.collection.hidict.Hidict">Hidict</a></code>.<code><a title="structpy.collection.hidict.Hidict.copy" href="hidict.html#structpy.collection.hidict.Hidict.copy">copy</a></code>
</p>
<div class="desc inherited"><p>D.copy() -&gt; a shallow copy of D</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="structpy.collection" href="index.html">collection</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="structpy.collection.hidir.Hidir" href="#structpy.collection.hidir.Hidir">Hidir</a></code></h4>
<ul class="two-column">
<li><code><a title="structpy.collection.hidir.Hidir.update" href="#structpy.collection.hidir.Hidir.update">update</a></code></li>
<li><code><a title="structpy.collection.hidir.Hidir.values" href="#structpy.collection.hidir.Hidir.values">values</a></code></li>
<li><code><a title="structpy.collection.hidir.Hidir.items" href="#structpy.collection.hidir.Hidir.items">items</a></code></li>
<li><code><a title="structpy.collection.hidir.Hidir.pop" href="hidict.html#structpy.collection.hidir.Hidir.pop">pop</a></code></li>
<li><code><a title="structpy.collection.hidir.Hidir.popitem" href="hidict.html#structpy.collection.hidir.Hidir.popitem">popitem</a></code></li>
<li><code><a title="structpy.collection.hidir.Hidir.setdefault" href="hidict.html#structpy.collection.hidir.Hidir.setdefault">setdefault</a></code></li>
<li><code><a title="structpy.collection.hidir.Hidir.get" href="hidict.html#structpy.collection.hidir.Hidir.get">get</a></code></li>
<li><code><a title="structpy.collection.hidir.Hidir.keys" href="hidict.html#structpy.collection.hidir.Hidir.keys">keys</a></code></li>
<li><code><a title="structpy.collection.hidir.Hidir.copy" href="hidict.html#structpy.collection.hidir.Hidir.copy">copy</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>