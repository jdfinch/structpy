<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.2" />
<title>standard.graph.dictionary_graph API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>standard.graph.dictionary_graph</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">from collections import deque

class DictionaryGraph:
    &#34;&#34;&#34;
    General directed graph implemented with dictionaries
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        `_nodes: dict&lt;pro: object, dict&lt;epi: object, edge: object&gt;&gt;` 
        &#34;&#34;&#34;
        self._nodes = {}

    def nodes(self):
        &#34;&#34;&#34;
        Returns an iterable over all nodes in the graph
        &#34;&#34;&#34;
        for node in self._nodes.keys():
            yield node

    def has_node(self, node):
        &#34;&#34;&#34;
        Checks node membership in the graph
        &#34;&#34;&#34;
        return node in self._nodes

    def edges(self):
        &#34;&#34;&#34;
        Returns an iterable over all edges (pairs of nodes) in the graph

        For each edge, the pro is accessed by edge[0], the epi by edge[1], 
        the value by edge[2]
        &#34;&#34;&#34;
        for pro in self._nodes.keys():
            for epi in self._nodes[pro]:
                yield (pro, epi, self._nodes[pro][epi]) 

    def has_edge(self, pro, epi):
        &#34;&#34;&#34;
        Checks edge membership in the graph
        &#34;&#34;&#34;
        return pro in self._nodes and epi in self._nodes[pro]

    def epis(self, pro):
        &#34;&#34;&#34;
        Returns an iterable over the epis of a given node
        &#34;&#34;&#34;
        for epi in self._nodes[pro]:
            yield epi

    def edge(self, pro, epi):
        &#34;&#34;&#34;
        Return the edge from node pro to node epi

        Raises exception if there is no edge from pro to epi
        &#34;&#34;&#34;
        return self._nodes[pro][epi]

    def add_node(self, node):
        &#34;&#34;&#34;
        Add a node to this graph if it doesn&#39;t already exist
        &#34;&#34;&#34;
        if node not in self._nodes:
            self._nodes[node] = {}

    def add_edge(self, pro, epi, edge=None):
        &#34;&#34;&#34;
        Add an edge between two existing nodes in the graph

        If the edge already exists, overwrite it with a new edge value

        Raises an exception if either node does not already exist in the graph
        &#34;&#34;&#34;
        self._nodes[pro][epi] = edge

    def add(self, pro, epi=None, edge=None):
        &#34;&#34;&#34;
        Add nodes pro and epi if they don&#39;t already exist, and set the edge between them

        If epi and pro are not specified, only pro will be added to the set of nodes
        &#34;&#34;&#34;
        self.add_node(pro)
        if epi is not None:
            if epi not in self._nodes:
                self.add_node(epi)
            self.add_edge(pro, epi, edge)

    def remove_node(self, node):
        &#34;&#34;&#34;
        Remove node from this graph
        &#34;&#34;&#34;
        del self._nodes[node]

    def remove_edge(self, pro, epi):
        &#34;&#34;&#34;
        Remove the edge between pro and epi
        &#34;&#34;&#34;
        del self._nodes[pro][epi]

    def traversal_breadthfirst(self, start):
        &#34;&#34;&#34;
        Traverse over nodes in breadth-first order starting with start node
        &#34;&#34;&#34;
        q = deque()
        q.append(start)
        visited = set()
        while q:
            n = q.popleft()
            yield n
            visited.add(n)
            for epi in self.epis(n):
                if epi not in visited:
                    q.append(epi)

    def traversal_postorder(self, start):
        &#34;&#34;&#34;
        Traverse over nodes in post-order starting with start node
        &#34;&#34;&#34;
        pass

    def traversal_preorder(self, start):
        &#34;&#34;&#34;
        Traverse over nodes in pre-order starting with start node
        &#34;&#34;&#34;
        pass

    def traversal_breadthfirst_if(self, start, condition):
        &#34;&#34;&#34;
        Traverse over nodes in breadth-first order starting with start node

        Nodes are only traversed, expanded, and yielded if condition(epi, edge)
        returns True, where epi is the node to expand and edge is the edge between
        epi and the pro that expanded to traverse to it

        `condition: function&lt;bool&gt;(pro, epi, edge)` 
        &#34;&#34;&#34;
        pass

    def traversal_postorder_if(self, start, condition):
        &#34;&#34;&#34;
        Traverse over nodes in post-order starting with start node

        Nodes are only traversed, expanded, and yielded if condition(epi, edge)
        returns True, where epi is the node to expand and edge is the edge between
        epi and the pro that expanded to traverse to it

        `condition: function&lt;bool&gt;(pro, epi, edge)` 
        &#34;&#34;&#34;
        pass

    def traversal_preorder_if(self, start, condition):
        &#34;&#34;&#34;
        Traverse over nodes in pre-order starting with start node

        Nodes are only traversed, expanded, and yielded if condition(epi, edge)
        returns True, where epi is the node to expand and edge is the edge between
        epi and the pro that expanded to traverse to it

        `condition: function&lt;bool&gt;(pro, epi, edge)` 
        &#34;&#34;&#34;
        pass

    def traversal_costorder(self, start, cost_function=None):
        &#34;&#34;&#34;
        Traverse the nodes in order of expansion cost, where lesser cost
        epis are expanded first

        `cost_function: function&lt;comparable&gt;(pro, epi, edge)`
        &#34;&#34;&#34;
        pass
            
    def search_breadthfirst(self, start, end_condition):
        &#34;&#34;&#34;
        Search over nodes in breadth-first order starting with start node
        until end_condition is reached

        End condition can be either a target node OR a condition function

        `end_condition: target: object 
                        OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)`
        &#34;&#34;&#34;
        pass

    def search_depthfirst(self, start, end_condition):
        &#34;&#34;&#34;
        Search over nodes in  depth-first order starting with start node
        until end_condition is reached

        End condition can be either a target node OR a condition function

        `end_condition: target: object 
                        OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)`
        &#34;&#34;&#34;
        pass

    def search_iterdepth(self, start, end_condition):
        &#34;&#34;&#34;
        Search over nodes in iterative deepening depth-first order starting with start 
        node until end_condition is reached

        End condition can be either a target node OR a condition function

        `end_condition: target: object 
                        OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)`
        &#34;&#34;&#34;
        pass

    def search_breadthfirst_if(self, start, condition, end_condition):
        &#34;&#34;&#34;
        Search over nodes in  breadth-first order starting with start node
        until end_condition is reached

        End condition can be either a target node OR a condition function

        Nodes are only traversed, expanded, and yielded if condition(epi, edge)
        returns True, where epi is the node to expand and edge is the edge between
        epi and the pro that expanded to traverse to it

        `end_condition: target: object 
                        OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)`

        `condition: function&lt;bool&gt;(pro, epi, edge)` 
        &#34;&#34;&#34;
        pass

    def search_depthfirst_if(self, start, condition, end_condition):
        &#34;&#34;&#34;
        Search over nodes in  depth-first order starting with start node
        until end_condition is reached

        End condition can be either a target node OR a condition function

        Nodes are only traversed, expanded, and yielded if condition(epi, edge)
        returns True, where epi is the node to expand and edge is the edge between
        epi and the pro that expanded to traverse to it

        `end_condition: target: object 
                        OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)`

        `condition: function&lt;bool&gt;(pro, epi, edge)` 
        &#34;&#34;&#34;
        pass

    def search_iterdepth_if(self, start, condition, end_condition):
        &#34;&#34;&#34;
        Search over nodes in iterative deepening depth-first order starting with start 
        node until end_condition is reached

        End condition can be either a target node OR a condition function

        Nodes are only traversed, expanded, and yielded if condition(epi, edge)
        returns True, where epi is the node to expand and edge is the edge between
        epi and the pro that expanded to traverse to it

        `end_condition: target: object 
                        OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)`

        `condition: function&lt;bool&gt;(pro, epi, edge)`
        &#34;&#34;&#34;
        pass

    def search_costorder(self, start, end_condition, cost_function=None):
        &#34;&#34;&#34;
        Search over nodes in order of least cost to expand the next node

        End condition can be either a target node OR a condition function

        `end_condition: target: object
                        OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)`

        `cost_function: function&lt;comparable&gt;(this: dictionary_graph, path: list&lt;object&gt;)`
        &#34;&#34;&#34;
        pass

    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="standard.graph.dictionary_graph.DictionaryGraph"><code class="flex name class">
<span>class <span class="ident">DictionaryGraph</span></span>
</code></dt>
<dd>
<section class="desc"><p>General directed graph implemented with dictionaries</p>
<p><code>_nodes: dict&lt;pro: object, dict&lt;epi: object, edge: object&gt;&gt;</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class DictionaryGraph:
    &#34;&#34;&#34;
    General directed graph implemented with dictionaries
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        `_nodes: dict&lt;pro: object, dict&lt;epi: object, edge: object&gt;&gt;` 
        &#34;&#34;&#34;
        self._nodes = {}

    def nodes(self):
        &#34;&#34;&#34;
        Returns an iterable over all nodes in the graph
        &#34;&#34;&#34;
        for node in self._nodes.keys():
            yield node

    def has_node(self, node):
        &#34;&#34;&#34;
        Checks node membership in the graph
        &#34;&#34;&#34;
        return node in self._nodes

    def edges(self):
        &#34;&#34;&#34;
        Returns an iterable over all edges (pairs of nodes) in the graph

        For each edge, the pro is accessed by edge[0], the epi by edge[1], 
        the value by edge[2]
        &#34;&#34;&#34;
        for pro in self._nodes.keys():
            for epi in self._nodes[pro]:
                yield (pro, epi, self._nodes[pro][epi]) 

    def has_edge(self, pro, epi):
        &#34;&#34;&#34;
        Checks edge membership in the graph
        &#34;&#34;&#34;
        return pro in self._nodes and epi in self._nodes[pro]

    def epis(self, pro):
        &#34;&#34;&#34;
        Returns an iterable over the epis of a given node
        &#34;&#34;&#34;
        for epi in self._nodes[pro]:
            yield epi

    def edge(self, pro, epi):
        &#34;&#34;&#34;
        Return the edge from node pro to node epi

        Raises exception if there is no edge from pro to epi
        &#34;&#34;&#34;
        return self._nodes[pro][epi]

    def add_node(self, node):
        &#34;&#34;&#34;
        Add a node to this graph if it doesn&#39;t already exist
        &#34;&#34;&#34;
        if node not in self._nodes:
            self._nodes[node] = {}

    def add_edge(self, pro, epi, edge=None):
        &#34;&#34;&#34;
        Add an edge between two existing nodes in the graph

        If the edge already exists, overwrite it with a new edge value

        Raises an exception if either node does not already exist in the graph
        &#34;&#34;&#34;
        self._nodes[pro][epi] = edge

    def add(self, pro, epi=None, edge=None):
        &#34;&#34;&#34;
        Add nodes pro and epi if they don&#39;t already exist, and set the edge between them

        If epi and pro are not specified, only pro will be added to the set of nodes
        &#34;&#34;&#34;
        self.add_node(pro)
        if epi is not None:
            if epi not in self._nodes:
                self.add_node(epi)
            self.add_edge(pro, epi, edge)

    def remove_node(self, node):
        &#34;&#34;&#34;
        Remove node from this graph
        &#34;&#34;&#34;
        del self._nodes[node]

    def remove_edge(self, pro, epi):
        &#34;&#34;&#34;
        Remove the edge between pro and epi
        &#34;&#34;&#34;
        del self._nodes[pro][epi]

    def traversal_breadthfirst(self, start):
        &#34;&#34;&#34;
        Traverse over nodes in breadth-first order starting with start node
        &#34;&#34;&#34;
        q = deque()
        q.append(start)
        visited = set()
        while q:
            n = q.popleft()
            yield n
            visited.add(n)
            for epi in self.epis(n):
                if epi not in visited:
                    q.append(epi)

    def traversal_postorder(self, start):
        &#34;&#34;&#34;
        Traverse over nodes in post-order starting with start node
        &#34;&#34;&#34;
        pass

    def traversal_preorder(self, start):
        &#34;&#34;&#34;
        Traverse over nodes in pre-order starting with start node
        &#34;&#34;&#34;
        pass

    def traversal_breadthfirst_if(self, start, condition):
        &#34;&#34;&#34;
        Traverse over nodes in breadth-first order starting with start node

        Nodes are only traversed, expanded, and yielded if condition(epi, edge)
        returns True, where epi is the node to expand and edge is the edge between
        epi and the pro that expanded to traverse to it

        `condition: function&lt;bool&gt;(pro, epi, edge)` 
        &#34;&#34;&#34;
        pass

    def traversal_postorder_if(self, start, condition):
        &#34;&#34;&#34;
        Traverse over nodes in post-order starting with start node

        Nodes are only traversed, expanded, and yielded if condition(epi, edge)
        returns True, where epi is the node to expand and edge is the edge between
        epi and the pro that expanded to traverse to it

        `condition: function&lt;bool&gt;(pro, epi, edge)` 
        &#34;&#34;&#34;
        pass

    def traversal_preorder_if(self, start, condition):
        &#34;&#34;&#34;
        Traverse over nodes in pre-order starting with start node

        Nodes are only traversed, expanded, and yielded if condition(epi, edge)
        returns True, where epi is the node to expand and edge is the edge between
        epi and the pro that expanded to traverse to it

        `condition: function&lt;bool&gt;(pro, epi, edge)` 
        &#34;&#34;&#34;
        pass

    def traversal_costorder(self, start, cost_function=None):
        &#34;&#34;&#34;
        Traverse the nodes in order of expansion cost, where lesser cost
        epis are expanded first

        `cost_function: function&lt;comparable&gt;(pro, epi, edge)`
        &#34;&#34;&#34;
        pass
            
    def search_breadthfirst(self, start, end_condition):
        &#34;&#34;&#34;
        Search over nodes in breadth-first order starting with start node
        until end_condition is reached

        End condition can be either a target node OR a condition function

        `end_condition: target: object 
                        OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)`
        &#34;&#34;&#34;
        pass

    def search_depthfirst(self, start, end_condition):
        &#34;&#34;&#34;
        Search over nodes in  depth-first order starting with start node
        until end_condition is reached

        End condition can be either a target node OR a condition function

        `end_condition: target: object 
                        OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)`
        &#34;&#34;&#34;
        pass

    def search_iterdepth(self, start, end_condition):
        &#34;&#34;&#34;
        Search over nodes in iterative deepening depth-first order starting with start 
        node until end_condition is reached

        End condition can be either a target node OR a condition function

        `end_condition: target: object 
                        OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)`
        &#34;&#34;&#34;
        pass

    def search_breadthfirst_if(self, start, condition, end_condition):
        &#34;&#34;&#34;
        Search over nodes in  breadth-first order starting with start node
        until end_condition is reached

        End condition can be either a target node OR a condition function

        Nodes are only traversed, expanded, and yielded if condition(epi, edge)
        returns True, where epi is the node to expand and edge is the edge between
        epi and the pro that expanded to traverse to it

        `end_condition: target: object 
                        OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)`

        `condition: function&lt;bool&gt;(pro, epi, edge)` 
        &#34;&#34;&#34;
        pass

    def search_depthfirst_if(self, start, condition, end_condition):
        &#34;&#34;&#34;
        Search over nodes in  depth-first order starting with start node
        until end_condition is reached

        End condition can be either a target node OR a condition function

        Nodes are only traversed, expanded, and yielded if condition(epi, edge)
        returns True, where epi is the node to expand and edge is the edge between
        epi and the pro that expanded to traverse to it

        `end_condition: target: object 
                        OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)`

        `condition: function&lt;bool&gt;(pro, epi, edge)` 
        &#34;&#34;&#34;
        pass

    def search_iterdepth_if(self, start, condition, end_condition):
        &#34;&#34;&#34;
        Search over nodes in iterative deepening depth-first order starting with start 
        node until end_condition is reached

        End condition can be either a target node OR a condition function

        Nodes are only traversed, expanded, and yielded if condition(epi, edge)
        returns True, where epi is the node to expand and edge is the edge between
        epi and the pro that expanded to traverse to it

        `end_condition: target: object 
                        OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)`

        `condition: function&lt;bool&gt;(pro, epi, edge)`
        &#34;&#34;&#34;
        pass

    def search_costorder(self, start, end_condition, cost_function=None):
        &#34;&#34;&#34;
        Search over nodes in order of least cost to expand the next node

        End condition can be either a target node OR a condition function

        `end_condition: target: object
                        OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)`

        `cost_function: function&lt;comparable&gt;(this: dictionary_graph, path: list&lt;object&gt;)`
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, pro, epi=None, edge=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Add nodes pro and epi if they don't already exist, and set the edge between them</p>
<p>If epi and pro are not specified, only pro will be added to the set of nodes</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add(self, pro, epi=None, edge=None):
    &#34;&#34;&#34;
    Add nodes pro and epi if they don&#39;t already exist, and set the edge between them

    If epi and pro are not specified, only pro will be added to the set of nodes
    &#34;&#34;&#34;
    self.add_node(pro)
    if epi is not None:
        if epi not in self._nodes:
            self.add_node(epi)
        self.add_edge(pro, epi, edge)</code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.add_edge"><code class="name flex">
<span>def <span class="ident">add_edge</span></span>(<span>self, pro, epi, edge=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Add an edge between two existing nodes in the graph</p>
<p>If the edge already exists, overwrite it with a new edge value</p>
<p>Raises an exception if either node does not already exist in the graph</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_edge(self, pro, epi, edge=None):
    &#34;&#34;&#34;
    Add an edge between two existing nodes in the graph

    If the edge already exists, overwrite it with a new edge value

    Raises an exception if either node does not already exist in the graph
    &#34;&#34;&#34;
    self._nodes[pro][epi] = edge</code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.add_node"><code class="name flex">
<span>def <span class="ident">add_node</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"><p>Add a node to this graph if it doesn't already exist</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_node(self, node):
    &#34;&#34;&#34;
    Add a node to this graph if it doesn&#39;t already exist
    &#34;&#34;&#34;
    if node not in self._nodes:
        self._nodes[node] = {}</code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.edge"><code class="name flex">
<span>def <span class="ident">edge</span></span>(<span>self, pro, epi)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the edge from node pro to node epi</p>
<p>Raises exception if there is no edge from pro to epi</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def edge(self, pro, epi):
    &#34;&#34;&#34;
    Return the edge from node pro to node epi

    Raises exception if there is no edge from pro to epi
    &#34;&#34;&#34;
    return self._nodes[pro][epi]</code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.edges"><code class="name flex">
<span>def <span class="ident">edges</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns an iterable over all edges (pairs of nodes) in the graph</p>
<p>For each edge, the pro is accessed by edge[0], the epi by edge[1],
the value by edge[2]</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def edges(self):
    &#34;&#34;&#34;
    Returns an iterable over all edges (pairs of nodes) in the graph

    For each edge, the pro is accessed by edge[0], the epi by edge[1], 
    the value by edge[2]
    &#34;&#34;&#34;
    for pro in self._nodes.keys():
        for epi in self._nodes[pro]:
            yield (pro, epi, self._nodes[pro][epi]) </code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.epis"><code class="name flex">
<span>def <span class="ident">epis</span></span>(<span>self, pro)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns an iterable over the epis of a given node</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def epis(self, pro):
    &#34;&#34;&#34;
    Returns an iterable over the epis of a given node
    &#34;&#34;&#34;
    for epi in self._nodes[pro]:
        yield epi</code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.has_edge"><code class="name flex">
<span>def <span class="ident">has_edge</span></span>(<span>self, pro, epi)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks edge membership in the graph</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def has_edge(self, pro, epi):
    &#34;&#34;&#34;
    Checks edge membership in the graph
    &#34;&#34;&#34;
    return pro in self._nodes and epi in self._nodes[pro]</code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.has_node"><code class="name flex">
<span>def <span class="ident">has_node</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks node membership in the graph</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def has_node(self, node):
    &#34;&#34;&#34;
    Checks node membership in the graph
    &#34;&#34;&#34;
    return node in self._nodes</code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.nodes"><code class="name flex">
<span>def <span class="ident">nodes</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns an iterable over all nodes in the graph</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def nodes(self):
    &#34;&#34;&#34;
    Returns an iterable over all nodes in the graph
    &#34;&#34;&#34;
    for node in self._nodes.keys():
        yield node</code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.remove_edge"><code class="name flex">
<span>def <span class="ident">remove_edge</span></span>(<span>self, pro, epi)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove the edge between pro and epi</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def remove_edge(self, pro, epi):
    &#34;&#34;&#34;
    Remove the edge between pro and epi
    &#34;&#34;&#34;
    del self._nodes[pro][epi]</code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.remove_node"><code class="name flex">
<span>def <span class="ident">remove_node</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove node from this graph</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def remove_node(self, node):
    &#34;&#34;&#34;
    Remove node from this graph
    &#34;&#34;&#34;
    del self._nodes[node]</code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.search_breadthfirst"><code class="name flex">
<span>def <span class="ident">search_breadthfirst</span></span>(<span>self, start, end_condition)</span>
</code></dt>
<dd>
<section class="desc"><p>Search over nodes in breadth-first order starting with start node
until end_condition is reached</p>
<p>End condition can be either a target node OR a condition function</p>
<p><code>end_condition: target: object
OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def search_breadthfirst(self, start, end_condition):
    &#34;&#34;&#34;
    Search over nodes in breadth-first order starting with start node
    until end_condition is reached

    End condition can be either a target node OR a condition function

    `end_condition: target: object 
                    OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)`
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.search_breadthfirst_if"><code class="name flex">
<span>def <span class="ident">search_breadthfirst_if</span></span>(<span>self, start, condition, end_condition)</span>
</code></dt>
<dd>
<section class="desc"><p>Search over nodes in
breadth-first order starting with start node
until end_condition is reached</p>
<p>End condition can be either a target node OR a condition function</p>
<p>Nodes are only traversed, expanded, and yielded if condition(epi, edge)
returns True, where epi is the node to expand and edge is the edge between
epi and the pro that expanded to traverse to it</p>
<p><code>end_condition: target: object
OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)</code></p>
<p><code>condition: function&lt;bool&gt;(pro, epi, edge)</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def search_breadthfirst_if(self, start, condition, end_condition):
    &#34;&#34;&#34;
    Search over nodes in  breadth-first order starting with start node
    until end_condition is reached

    End condition can be either a target node OR a condition function

    Nodes are only traversed, expanded, and yielded if condition(epi, edge)
    returns True, where epi is the node to expand and edge is the edge between
    epi and the pro that expanded to traverse to it

    `end_condition: target: object 
                    OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)`

    `condition: function&lt;bool&gt;(pro, epi, edge)` 
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.search_costorder"><code class="name flex">
<span>def <span class="ident">search_costorder</span></span>(<span>self, start, end_condition, cost_function=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Search over nodes in order of least cost to expand the next node</p>
<p>End condition can be either a target node OR a condition function</p>
<p><code>end_condition: target: object
OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)</code></p>
<p><code>cost_function: function&lt;comparable&gt;(this: dictionary_graph, path: list&lt;object&gt;)</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def search_costorder(self, start, end_condition, cost_function=None):
    &#34;&#34;&#34;
    Search over nodes in order of least cost to expand the next node

    End condition can be either a target node OR a condition function

    `end_condition: target: object
                    OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)`

    `cost_function: function&lt;comparable&gt;(this: dictionary_graph, path: list&lt;object&gt;)`
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.search_depthfirst"><code class="name flex">
<span>def <span class="ident">search_depthfirst</span></span>(<span>self, start, end_condition)</span>
</code></dt>
<dd>
<section class="desc"><p>Search over nodes in
depth-first order starting with start node
until end_condition is reached</p>
<p>End condition can be either a target node OR a condition function</p>
<p><code>end_condition: target: object
OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def search_depthfirst(self, start, end_condition):
    &#34;&#34;&#34;
    Search over nodes in  depth-first order starting with start node
    until end_condition is reached

    End condition can be either a target node OR a condition function

    `end_condition: target: object 
                    OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)`
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.search_depthfirst_if"><code class="name flex">
<span>def <span class="ident">search_depthfirst_if</span></span>(<span>self, start, condition, end_condition)</span>
</code></dt>
<dd>
<section class="desc"><p>Search over nodes in
depth-first order starting with start node
until end_condition is reached</p>
<p>End condition can be either a target node OR a condition function</p>
<p>Nodes are only traversed, expanded, and yielded if condition(epi, edge)
returns True, where epi is the node to expand and edge is the edge between
epi and the pro that expanded to traverse to it</p>
<p><code>end_condition: target: object
OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)</code></p>
<p><code>condition: function&lt;bool&gt;(pro, epi, edge)</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def search_depthfirst_if(self, start, condition, end_condition):
    &#34;&#34;&#34;
    Search over nodes in  depth-first order starting with start node
    until end_condition is reached

    End condition can be either a target node OR a condition function

    Nodes are only traversed, expanded, and yielded if condition(epi, edge)
    returns True, where epi is the node to expand and edge is the edge between
    epi and the pro that expanded to traverse to it

    `end_condition: target: object 
                    OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)`

    `condition: function&lt;bool&gt;(pro, epi, edge)` 
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.search_iterdepth"><code class="name flex">
<span>def <span class="ident">search_iterdepth</span></span>(<span>self, start, end_condition)</span>
</code></dt>
<dd>
<section class="desc"><p>Search over nodes in iterative deepening depth-first order starting with start
node until end_condition is reached</p>
<p>End condition can be either a target node OR a condition function</p>
<p><code>end_condition: target: object
OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def search_iterdepth(self, start, end_condition):
    &#34;&#34;&#34;
    Search over nodes in iterative deepening depth-first order starting with start 
    node until end_condition is reached

    End condition can be either a target node OR a condition function

    `end_condition: target: object 
                    OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)`
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.search_iterdepth_if"><code class="name flex">
<span>def <span class="ident">search_iterdepth_if</span></span>(<span>self, start, condition, end_condition)</span>
</code></dt>
<dd>
<section class="desc"><p>Search over nodes in iterative deepening depth-first order starting with start
node until end_condition is reached</p>
<p>End condition can be either a target node OR a condition function</p>
<p>Nodes are only traversed, expanded, and yielded if condition(epi, edge)
returns True, where epi is the node to expand and edge is the edge between
epi and the pro that expanded to traverse to it</p>
<p><code>end_condition: target: object
OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)</code></p>
<p><code>condition: function&lt;bool&gt;(pro, epi, edge)</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def search_iterdepth_if(self, start, condition, end_condition):
    &#34;&#34;&#34;
    Search over nodes in iterative deepening depth-first order starting with start 
    node until end_condition is reached

    End condition can be either a target node OR a condition function

    Nodes are only traversed, expanded, and yielded if condition(epi, edge)
    returns True, where epi is the node to expand and edge is the edge between
    epi and the pro that expanded to traverse to it

    `end_condition: target: object 
                    OR function&lt;bool&gt;(this: dictionary_graph, path: list&lt;object&gt;)`

    `condition: function&lt;bool&gt;(pro, epi, edge)`
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.traversal_breadthfirst"><code class="name flex">
<span>def <span class="ident">traversal_breadthfirst</span></span>(<span>self, start)</span>
</code></dt>
<dd>
<section class="desc"><p>Traverse over nodes in breadth-first order starting with start node</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def traversal_breadthfirst(self, start):
    &#34;&#34;&#34;
    Traverse over nodes in breadth-first order starting with start node
    &#34;&#34;&#34;
    q = deque()
    q.append(start)
    visited = set()
    while q:
        n = q.popleft()
        yield n
        visited.add(n)
        for epi in self.epis(n):
            if epi not in visited:
                q.append(epi)</code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.traversal_breadthfirst_if"><code class="name flex">
<span>def <span class="ident">traversal_breadthfirst_if</span></span>(<span>self, start, condition)</span>
</code></dt>
<dd>
<section class="desc"><p>Traverse over nodes in breadth-first order starting with start node</p>
<p>Nodes are only traversed, expanded, and yielded if condition(epi, edge)
returns True, where epi is the node to expand and edge is the edge between
epi and the pro that expanded to traverse to it</p>
<p><code>condition: function&lt;bool&gt;(pro, epi, edge)</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def traversal_breadthfirst_if(self, start, condition):
    &#34;&#34;&#34;
    Traverse over nodes in breadth-first order starting with start node

    Nodes are only traversed, expanded, and yielded if condition(epi, edge)
    returns True, where epi is the node to expand and edge is the edge between
    epi and the pro that expanded to traverse to it

    `condition: function&lt;bool&gt;(pro, epi, edge)` 
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.traversal_costorder"><code class="name flex">
<span>def <span class="ident">traversal_costorder</span></span>(<span>self, start, cost_function=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Traverse the nodes in order of expansion cost, where lesser cost
epis are expanded first</p>
<p><code>cost_function: function&lt;comparable&gt;(pro, epi, edge)</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def traversal_costorder(self, start, cost_function=None):
    &#34;&#34;&#34;
    Traverse the nodes in order of expansion cost, where lesser cost
    epis are expanded first

    `cost_function: function&lt;comparable&gt;(pro, epi, edge)`
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.traversal_postorder"><code class="name flex">
<span>def <span class="ident">traversal_postorder</span></span>(<span>self, start)</span>
</code></dt>
<dd>
<section class="desc"><p>Traverse over nodes in post-order starting with start node</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def traversal_postorder(self, start):
    &#34;&#34;&#34;
    Traverse over nodes in post-order starting with start node
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.traversal_postorder_if"><code class="name flex">
<span>def <span class="ident">traversal_postorder_if</span></span>(<span>self, start, condition)</span>
</code></dt>
<dd>
<section class="desc"><p>Traverse over nodes in post-order starting with start node</p>
<p>Nodes are only traversed, expanded, and yielded if condition(epi, edge)
returns True, where epi is the node to expand and edge is the edge between
epi and the pro that expanded to traverse to it</p>
<p><code>condition: function&lt;bool&gt;(pro, epi, edge)</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def traversal_postorder_if(self, start, condition):
    &#34;&#34;&#34;
    Traverse over nodes in post-order starting with start node

    Nodes are only traversed, expanded, and yielded if condition(epi, edge)
    returns True, where epi is the node to expand and edge is the edge between
    epi and the pro that expanded to traverse to it

    `condition: function&lt;bool&gt;(pro, epi, edge)` 
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.traversal_preorder"><code class="name flex">
<span>def <span class="ident">traversal_preorder</span></span>(<span>self, start)</span>
</code></dt>
<dd>
<section class="desc"><p>Traverse over nodes in pre-order starting with start node</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def traversal_preorder(self, start):
    &#34;&#34;&#34;
    Traverse over nodes in pre-order starting with start node
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="standard.graph.dictionary_graph.DictionaryGraph.traversal_preorder_if"><code class="name flex">
<span>def <span class="ident">traversal_preorder_if</span></span>(<span>self, start, condition)</span>
</code></dt>
<dd>
<section class="desc"><p>Traverse over nodes in pre-order starting with start node</p>
<p>Nodes are only traversed, expanded, and yielded if condition(epi, edge)
returns True, where epi is the node to expand and edge is the edge between
epi and the pro that expanded to traverse to it</p>
<p><code>condition: function&lt;bool&gt;(pro, epi, edge)</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def traversal_preorder_if(self, start, condition):
    &#34;&#34;&#34;
    Traverse over nodes in pre-order starting with start node

    Nodes are only traversed, expanded, and yielded if condition(epi, edge)
    returns True, where epi is the node to expand and edge is the edge between
    epi and the pro that expanded to traverse to it

    `condition: function&lt;bool&gt;(pro, epi, edge)` 
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="standard.graph" href="index.html">standard.graph</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="standard.graph.dictionary_graph.DictionaryGraph" href="#standard.graph.dictionary_graph.DictionaryGraph">DictionaryGraph</a></code></h4>
<ul class="">
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.add" href="#standard.graph.dictionary_graph.DictionaryGraph.add">add</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.add_edge" href="#standard.graph.dictionary_graph.DictionaryGraph.add_edge">add_edge</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.add_node" href="#standard.graph.dictionary_graph.DictionaryGraph.add_node">add_node</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.edge" href="#standard.graph.dictionary_graph.DictionaryGraph.edge">edge</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.edges" href="#standard.graph.dictionary_graph.DictionaryGraph.edges">edges</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.epis" href="#standard.graph.dictionary_graph.DictionaryGraph.epis">epis</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.has_edge" href="#standard.graph.dictionary_graph.DictionaryGraph.has_edge">has_edge</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.has_node" href="#standard.graph.dictionary_graph.DictionaryGraph.has_node">has_node</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.nodes" href="#standard.graph.dictionary_graph.DictionaryGraph.nodes">nodes</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.remove_edge" href="#standard.graph.dictionary_graph.DictionaryGraph.remove_edge">remove_edge</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.remove_node" href="#standard.graph.dictionary_graph.DictionaryGraph.remove_node">remove_node</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.search_breadthfirst" href="#standard.graph.dictionary_graph.DictionaryGraph.search_breadthfirst">search_breadthfirst</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.search_breadthfirst_if" href="#standard.graph.dictionary_graph.DictionaryGraph.search_breadthfirst_if">search_breadthfirst_if</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.search_costorder" href="#standard.graph.dictionary_graph.DictionaryGraph.search_costorder">search_costorder</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.search_depthfirst" href="#standard.graph.dictionary_graph.DictionaryGraph.search_depthfirst">search_depthfirst</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.search_depthfirst_if" href="#standard.graph.dictionary_graph.DictionaryGraph.search_depthfirst_if">search_depthfirst_if</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.search_iterdepth" href="#standard.graph.dictionary_graph.DictionaryGraph.search_iterdepth">search_iterdepth</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.search_iterdepth_if" href="#standard.graph.dictionary_graph.DictionaryGraph.search_iterdepth_if">search_iterdepth_if</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.traversal_breadthfirst" href="#standard.graph.dictionary_graph.DictionaryGraph.traversal_breadthfirst">traversal_breadthfirst</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.traversal_breadthfirst_if" href="#standard.graph.dictionary_graph.DictionaryGraph.traversal_breadthfirst_if">traversal_breadthfirst_if</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.traversal_costorder" href="#standard.graph.dictionary_graph.DictionaryGraph.traversal_costorder">traversal_costorder</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.traversal_postorder" href="#standard.graph.dictionary_graph.DictionaryGraph.traversal_postorder">traversal_postorder</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.traversal_postorder_if" href="#standard.graph.dictionary_graph.DictionaryGraph.traversal_postorder_if">traversal_postorder_if</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.traversal_preorder" href="#standard.graph.dictionary_graph.DictionaryGraph.traversal_preorder">traversal_preorder</a></code></li>
<li><code><a title="standard.graph.dictionary_graph.DictionaryGraph.traversal_preorder_if" href="#standard.graph.dictionary_graph.DictionaryGraph.traversal_preorder_if">traversal_preorder_if</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>